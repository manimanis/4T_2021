<!DOCTYPE html>
<html lang="fr">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Sous-programmes</title>
  <link rel="stylesheet" href="resources/css/bootstrap.min.css">
  <link rel="stylesheet" href="resources/css/default.css">
  <link rel="stylesheet" href="resources/css/style.css">
</head>

<body>
  <aside>
    <nav class="navbar navbar-expand-md navbar-dark bg-dark">
      <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#aside_navbar"
        aria-controls="navbarNavDropdown" aria-expanded="false" aria-label="Toggle navigation">
        <span class="navbar-toggler-icon"></span> Menu
      </button>
      <div class="collapse navbar-collapse" id="aside_navbar"></div>
    </nav>
  </aside>

  <main class="container my-3">
    <h1>Sous-programmes</h1>

    <article>
      <h2>Sous-programmes</h2>

      <section>
        <h3>Fraction irr√©ductible</h3>

        <p>En math√©matiques, une <strong>fraction est irr√©ductible</strong> s'il n'existe pas de fraction √©gale ayant
          des termes plus petits. Autrement dit, une fraction irr√©ductible <strong><u>ne peut pas √™tre
              simplifi√©e</u></strong>.</p>

        <h4>Th√©or√®me</h4>
        <p>Soient <strong>a</strong> un entier et <strong>b</strong> un entier naturel non nul. Alors <img
            src="resources/chapitre_04/images/fraction-a-b.svg" alt="a/b" class="h1cm"> est irr√©ductible si et
          seulement si
          <strong>a</strong> et <strong>b</strong> sont premiers entre eux.
        </p>

        <h5>Exemple</h5>
        <p>La fraction <img src="resources/chapitre_04/images/fraction-12-20.svg" alt="12/20" class="h1cm"> n'est pas
          irr√©ductible
          car 12 et 20 sont des multiples de 4 : <img src="resources/chapitre_04/images/fraction-12-20-01.svg"
            alt="12/20" class="h1cm"> (simplification par 4).
          On peut aussi √©crire <img src="resources/chapitre_04/images/fraction-12-20-02.svg" alt="12/20" class="h1cm">.
        </p>

        <p>La fraction <img src="resources/chapitre_04/images/fraction-3-5.svg" alt="3/5" class="h1cm"> est
          irr√©ductible car 1 est le
          seul entier positif qui divise √† la fois 3 et 5.</p>

        <h4>M√©thode de simplification</h4>

        <p>Pour r√©duire directement une fraction, il suffit de <strong>diviser le num√©rateur et le d√©nominateur par leur
            plus grand commun diviseur</strong>. D'apr√®s le lemme de Gauss, cette forme r√©duite est unique.</p>

        <h5>Exemple</h5>
        <p>Pour r√©duire la fraction <img src="resources/chapitre_04/images/fraction-42-390.svg" alt="42/390"
            class="h1cm">, on
          calcule <img src="resources/chapitre_04/images/pgcd-42-390.svg" alt="PGCD(42, 390)=6" class="h1cm"> puis on
          simplifie par 6
          : <img src="resources/chapitre_04/images/fraction-42-390-01.svg" alt="42/390=7/65" class="h1cm">.</p>
      </section>

      <section>
        <h3>Probl√®me</h3>

        <p>On souhaite √©crire un programme qui calcule la somme de deux fractions :</p>
        <figure>
          <img src="resources/chapitre_04/images/fraction-somme.svg" alt="p1/q1+p2/q2=ps/qs" class="h1_5cm">
          <figcaption>Somme de deux fractions avec : p1, p2, ps &in; &zopf; et q1, q2, qs &in; &zopf;<sup>*</sup>
          </figcaption>
        </figure>

        <p>Pour r√©soudre ce probl√®me on propose l'algorithme suivant :</p>
        <div class="row">
          <div class="col-sm-8">
            <pre><code class="language-algorithm">Algorithme Somme_Fraction
D√©but
  // Saisie des deux fractions
  saisie_fraction(p1, q1)
  saisie_fraction(p2, q2)
  // Simplifier les deux fractions
  simplifier_fraction(p1, q1)
  simplifier_fraction(p2, q2)
  // Calculer la somme des deux fractions
  // Puis la simplifier
  somme_fraction(p1, q1, p2, q2, ps, qs)
  // Afficher le r√©sultat
  Ecrire(p1, "/", q1, "+", p2, "/", q2, "=", ps, "/", qs)
Fin</code></pre>
          </div>
          <div class="col-sm-4">
            <table class="table table-sm table-bordered border-dark table-striped table-hover">
              <thead>
                <tr>
                  <th>Objet</th>
                  <th>Type/Nature</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>p1, q1, p2, q2, ps, qs</td>
                  <td>entier</td>
                </tr>
                <tr>
                  <td>saisie_fraction<br>simplifier<br>somme_fraction</td>
                  <td>proc√©dure</td>
                </tr>
              </tbody>
            </table>
          </div>
        </div>

        <p>Ce programme qui semble, au d√©but, compliqu√© est devenu assez simple gr√¢ce √† la <strong>d√©composition
            modulaire</strong>.</p>
      </section>

      <section>
        <h3>D√©composition modulaire</h3>

        <p>L'<strong>analyse modulaire</strong>, appel√©e √©galement <strong>d√©composition modulaire</strong>, consiste √†
          <ins>diviser un probl√®me en sous probl√®mes de difficult√©s moindres</ins>.
        </p>

        <p>En algorithmique, les <strong>sous probl√®mes</strong> correspondent √† des <strong>sous-programmes</strong>.
        </p>

        <h4>Sous-programme</h4>

        <p>Un <strong>sous-programme</strong> est une <ins>section de code nomm√©e</ins> <strong><em>qui peut √™tre
              appel√©e</em></strong> en √©crivant le nom du sous-programme dans une instruction du programme.</p>
        <p>Les <strong>sous-programmes</strong> sont √©galement appel√©s <strong>proc√©dures</strong> ou
          <strong>fonctions</strong>.
        </p>
        <p>Une <strong>proc√©dure</strong> ex√©cute simplement un ensemble d'instructions, tandis qu'une
          <strong>fonction</strong> renvoie une valeur une fois son ex√©cution est termin√©e.
        </p>
        <figure>
          <img src="resources/chapitre_04/images/fonction-procedure.png" class="h4cm"
            alt="Diff√©rence entre une proc√©dure et une fonction">
          <figcaption>Diff√©rence entre une proc√©dure et une fonction</figcaption>
        </figure>
        <p>L'√©criture de <strong>sous-programmes</strong> <ins>rend le code plus lisible et r√©utilisable</ins>, car le
          code est subdivis√© en des sections plus petites.</p>
        <p>La plupart des langages de programmation sont livr√©s avec un ensemble de sous-programmes int√©gr√©s, mais
          permettent, aussi, au programmeur d'√©crire leurs propres sous-programmes personnalis√©s.</p>
        <figure>
          <img src="resources/chapitre_04/images/decomposition-modulaire.png" class="h7cm"
            alt="D√©composition modulaire">
          <figcaption>D√©composition modulaire du probl√®me de la somme des deux fractions</figcaption>
        </figure>
      </section>

      <section>
        <h3>Fonction</h3>

        <h4>D√©finition</h4>
        <p>Une <strong>fonction</strong> est un sous-programme <strong>qui retourne <ins>√† son appelant</ins> un seul
            r√©sultat</strong> <em>en fonction de ses param√®tres</em>.</p>
        <p>Une <strong>fonction</strong> peut avoir z√©ro ou plusieurs param√®tres. Ces <strong>param√®tres</strong> sont
          <strong><em>souvent transmis par valeur</em></strong>.
        </p>

        <h4>Appel</h4>
        <p>Comme une <strong>fonction renvoie toujours une valeur</strong>, son appel peut se faire de diff√©rentes
          mani√®res :</p>
        <ul>
          <li>Dans une affectation :
            <pre><code class="language-algorithm">// pgcd(a, b) renvoie le PGCD des deux valeurs
dc &larr; pgcd(a, b)</code></pre>
          </li>
          <li>Dans une structure conditionnelle :
            <pre><code class="language-algorithm">// Afficher si un nombre est premier
Si premier(n) Alors
  Ecrire(n, "est premier")
Sinon
  Ecrire(n, "n'est pas premier")
Fin Si</code></pre>
          </li>
          <li class="p-break">Dans une structure it√©rative :
            <div class="row">
              <div class="col-sm-6">
                <pre><code class="language-algorithm">// f(x) est une fonction qui admet un extr√©mum
// en x0 &in; [0, +&infin;[
// Recherche de l'extr√©mum de f(x)
x0 &larr; 0
TantQue (f(x0+pas) > f(x0)) Faire
  x0 &larr; x0 + pas
Fin TantQue</code></pre>
              </div>
              <div class="col-sm-6">
                <pre><code class="language-algorithm">// Saisir une chaine alphab√©tique
// est_alphabetique(ch) : retrourne Vrai
// Si ch[i] &in; ["A", "Z"] &Union; ["a", "z"] 
R√©p√©ter
  Ecrire("Une chaine alphab√©tique ? ")
  Lire(ch)
Jusqu'√† est_alphabetique(ch)</code></pre>
              </div>
              <div class="col-sm-12">
                <pre><code class="language-algorithm">// Saisie d'un tableau de valeurs distinctes
// entre les indices n1 et n2
// Les fonctions :
// - min(a, b) : renvoie le minimum entre a et b
// - max(a, b) : renvoie le maximum entre a et b
// - existe(v, t, n) : recherche l'existence de v dans les n premi√®res cases de t
Pour i de min(n1, n2) √† max(n1, n2)-1 Faire
  R√©p√©ter
    Ecrire("t[", i, "] ? ")
    Lire(t[i])
  Jusqu'√† (non existe(t[i], t, i-1))
Fin TantQue</code></pre>
              </div>
            </div>
          </li>
          <li>Comme param√®tre d'un autre sous-programme :
            <div class="row">
              <div class="col-sm-6">
                <pre><code class="language-algorithm">// somme_carre(a, b) renvoie a¬≤ + b¬≤
Ecrire(somme_carre(a, b))</code></pre>
              </div>
              <div class="col-sm-6">
                <pre><code class="language-algorithm">// calculer PGCD de a, b et c
dc &larr; pgcd(a, pgcd(b, c))</code></pre>
              </div>
            </div>
          </li>
        </ul>

        <h4>Vocabulaire et Syntaxe</h4>
        <div class="row">
          <div class="col-sm-6">
            <p>Une fonction s'√©crit comme suit en algorithmique :</p>
            <pre><code class="language-algorithm">Fonction NomFonction(p<sub>1</sub>: type<sub>1</sub>, p<sub>2</sub>: type<sub>2</sub>, ..., 
                     p<sub>n</sub>: type<sub>n</sub>):type<sub>r√©sultat</sub>
  //
  // Traitements
  //
  <strong>Retourner</strong> r√©sultat
Fin</code></pre>
          </div>
          <div class="col-sm-6">
            <p>Son √©quivalent en Python s'√©crit comme suit :</p>
            <pre><code class="language-python">def NomFonction(p<sub>1</sub>, p<sub>2</sub>, ..., p<sub>n</sub>):
    
    #
    # Traitements
    #
    <strong>return</strong> r√©sultat
  </code></pre>
          </div>
        </div>
      </section>

      <section>
        <h3>Proc√©dure</h3>

        <h4>D√©finition</h4>
        <p>Une <strong>proc√©dure</strong> est un sous-programme <strong>qui ne retourne pas, directement, de r√©sultats
            <ins>√† son appelant</ins></strong>.</p>
        <p>Une <strong>proc√©dure</strong> peut avoir z√©ro ou plusieurs param√®tres. Ces <strong>param√®tres</strong>
          peuvent √™tre, selon le besoin, <strong><em>transmis par <ins>valeur</ins></em></strong> ou
          <strong><em>transmis par <ins>variable</ins></em></strong>.
        </p>
        <p>En algorithmique, le <strong>mode de passage par variable</strong> <em>est utilis√© pour renvoyer,
            indirectement, un ou plusieurs r√©sultats √† l'appelant</em>. Lorsqu'une proc√©dure renvoie des r√©sultats √†
          travers ses param√®tres, on dit qu'<strong>elle poss√®de un effet de bord</strong>.</p>

        <h4>Appel</h4>
        <p>Comme une <strong>proc√©dure ne renvoie aucune valeur</strong>, son appel se fait toujours de la m√™me
          fa√ßon :</p>
        <pre><code class="language-algorithm">// Saisir une valeur dans n
saisir(n)
// Remplir le tableau t par n valeurs distinctes
remplir_tab(t, n)
// Echanger le contenu de deux variables
permuter(a, b)</code></pre>
        <p>Une <strong>proc√©dure</strong> utilise les param√®tres pass√©s par valeur pour r√©aliser ses traitements. Elle
          peut, aussi, <ins>modifier la valeur des param√®tres transmis par variable</ins>, directement, chez l'appelant.
        </p>

        <h4>Vocabulaire & Syntaxe</h4>
        <div class="row">
          <div class="col-sm-6">
            <p>Une fonction s'√©crit comme suit en algorithmique :</p>
            <pre><code class="language-algorithm">Proc√©dure NomProc√©dure(p<sub>1</sub>: type<sub>1</sub>, p<sub>2</sub>: type<sub>2</sub>, ..., p<sub>n</sub>: type<sub>n</sub>)</sub>
  //
  // Traitements
  //
Fin</code></pre>
          </div>
          <div class="col-sm-6">
            <p>En Python, il n'y a pas d'√©quivalent pour une proc√©dure. On utilise pour cel√† une fonction :</p>
            <pre><code class="language-python">def NomProcedure(p<sub>1</sub>, ..., p<sub>n</sub>):
    #
    # Traitements
    #
  </code></pre>
          </div>
        </div>
      </section>

      <section>
        <h3>Solution</h3>

        <h4>Probl√®me</h4>
        <p>On souhaite √©crire un programme qui calcule la somme de deux fractions :</p>
        <figure>
          <img src="resources/chapitre_04/images/fraction-somme.svg" alt="p1/q1+p2/q2=ps/qs" class="h1_5cm">
          <figcaption>Somme de deux fractions avec : p1, p2, ps &in; &zopf; et q1, q2, qs &in; &zopf;<sup>*</sup>
          </figcaption>
        </figure>

        <h4>Solution</h4>
        <p>Nous avons d√©j√† donn√© l'algorithme du programme principal qui fait appel √† un ensemble de sous-programmes que
          nous allons d√©tailler ici.</p>

        <h4>Proc√©dure saisie_fraction</h4>
        <p>La proc√©dure <strong>saisie_fraction</strong> permet √† l'utilisateur d'introduire deux entiers qui
          repr√©sentent une fraction. Le d√©nominateur ne doit pas √™tre null.</p>

        <div class="row">
          <div class="col-sm-6">
            <pre><code class="language-algorithm">proc√©dure saisie_fraction(@num, @denom: entier)
D√©but
  Ecrire("Num√©rateur ? "); Lire(num)
  R√©p√©ter
    Ecrire("D√©nominateur &ne; 0 ? "); Lire(denom)
  Jusqu'√† denom &ne; 0
Fin</code></pre>
          </div>
          <div class="col-sm-6">
            <pre><code class="language-python">def saisie_fraction():
    p = int(input("Num√©rateur ? "))
    q = 0
    while not (q != 0):
        q = int(input("D√©nominateur ‚â†¬†0 ? "))
    return p, q</code></pre>
          </div>
        </div>

        <h4>Proc√©dure simplifier_fraction</h4>
        <p>La proc√©dure <strong>simplifier_fraction</strong> utilise la m√©thode expos√©e au d√©but de ce cours pour
          retrouver la fraction irreductible correspondant √† la fraction saisie par l'utilisateur.</p>
        <div class="row">
          <div class="col-sm-6">
            <pre><code class="language-algorithm">proc√©dure simplifier_fraction(@num, @denom: entier)
D√©but
  dc &larr; pgcd(num, denom)
  num &larr; num div dc
  denom &larr; denom div dc
Fin</code></pre>
          </div>
          <div class="col-sm-6">
            <pre><code class="language-python">def simplifier_fraction(p, q):
    dc = pgcd(p, q)
    p = p // dc
    q = q // dc
    return p, q</code></pre>
          </div>
        </div>

        <h4>Proc√©dure somme_fraction</h4>
        <p>La proc√©dure <strong>somme_fraction</strong> calcule la fraction irreductible correspondant √† la somme de
          deux fractions.</p>
        <div class="row">
          <div class="col-sm-6">
            <pre><code class="language-algorithm">proc√©dure simplifier_fraction(p1, q1, p2, q2: entier; 
                              @num, @denom: entier)
D√©but
  num &larr; p1 * q2 + p2 * q1
  denom &larr; q1 * q2
  simplifier_fraction(num, denom)
Fin</code></pre>
          </div>
          <div class="col-sm-6">
            <pre><code class="language-python">def somme_fraction(p1, q1, p2, q2):
    p = p1 * q2 + p2 * q1
    q = q1 * q2
    return simplifier_fraction(p, q)</code></pre>
          </div>
        </div>

        <h4>Fonction pgcd</h4>
        <p>La m√©thode de simplification expos√©e dans ce cours n√©cessite le calcul du PGCD du num√©rateur et du
          d√©nominateur de la fraction √† simplifier. C'est la fonction de <strong>pgcd</strong>.</p>
        <div class="row">
          <div class="col-sm-6">
            <pre><code class="language-algorithm">Fonction pgcd(a, b: entier):entier
D√©but
  TantQue b &ne; 0 Faire
    r &larr; a mod b
    a &larr; b
    b &larr; r
  Fin TantQue
  retourner a
Fin</code></pre>
          </div>
          <div class="col-sm-6">
            <pre><code class="language-python">def pgcd(a, b):
    while b != 0:
        r = a % b
        a = b
        b = r
    return a</code></pre>
          </div>
        </div>

        <h4 class="p-break">Programme Principal</h4>
        <p>Le programme principal est la partie la plus importante d'un programme car elle fait appel aux diff√©rents
          sous-programmes qui ont √©t√© d√©clar√© pr√©c√©demment. Une <strong>fonction</strong> ou une
          <strong>proc√©dure</strong> doivent √™tre appel√©s pour r√©soudre un probl√®me quelconque.</p>
        <div class="row">
          <div class="col-sm-6">
            <pre><code class="language-algorithm">Algorithme Somme_Fraction
D√©but
  // Saisie des deux fractions
  saisie_fraction(p1, q1)
  saisie_fraction(p2, q2)
  // Simplifier les deux fractions
  simplifier_fraction(p1, q1)
  simplifier_fraction(p2, q2)
  // Calculer la somme des deux fractions
  // Puis la simplifier
  somme_fraction(p1, q1, p2, q2, ps, qs)
  // Afficher le r√©sultat
  Ecrire(p1, "/", q1, "+", p2, "/", q2, "=", ps, "/", qs)
Fin</code></pre>
          </div>
          <div class="col-sm-6">
            <pre><code class="language-python"># PP
p1, q1 = saisie_fraction()
p2, q2 = saisie_fraction()

p1, q1 = simplifier_fraction(p1, q1)
p2, q2 = simplifier_fraction(p2, q2)
ps, qs = somme_fraction(p1, q1, p2, q2)

print(p1, "/", q1, "+", p2, "/", q2, "=", ps, "/", qs)</code></pre>
          </div>
        </div>
      </section>
    </article>
  </main>
  <footer class="d-print-none bg-dark text-white p-2">
    <div class="text-center">Page cr√©√©e avec ‚ô• par Mohamed Anis MANI</div>
    <div class="text-center small">Ann√©e scolaire : 2021/2022</div>
  </footer>

  <script src="resources/js/jquery.min.js"></script>
  <script src="resources/js/bootstrap.bundle.min.js"></script>
  <script src="resources/js/highlight.min.js"></script>
  <script src="resources/js/hljs.algorithm.js"></script>
  <script src="resources/js/clipboard.min.js"></script>
  <script src="resources/js/pages.js"></script>
  <script>
    hljs.initHighlightingOnLoad();

    document.querySelectorAll('.language-algorithm,.language-python,.language-delphi')
      .forEach(item => {
        const div = document.createElement('div');
        div.className = 'bd-clipboard d-print-none';
        const btn = document.createElement('button');
        btn.className = 'btn-clipboard';
        btn.textContent = "üìã";
        btn.title = "Copier";
        div.appendChild(btn);
        item.parentElement.insertBefore(div, item);
      });
    new ClipboardJS('.btn-clipboard', {
      target: (trigger) => {
        return trigger.parentElement.nextElementSibling;
      }
    });
  </script>

  <script src="resources/js/funcs.js"></script>
  <script src="resources/js/vue.min.js"></script>
  <script src="resources/apps/chapitre03.js"></script>
</body>

</html>